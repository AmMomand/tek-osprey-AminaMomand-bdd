package Tek_Retail_Framework_Notes_AfterWeekOne.week_1.day_1;

public class AM_Notes {
/*
1. Automation Pre_Requisitions:
   Before writing automation tests in Java using Selenium with Cucumber, you need to ensure you have the following
   prerequisites:

	1.	Java Development Kit (JDK): Install JDK on your system. Selenium with Cucumber is typically written in Java, so
	    you need JDK to compile and run Java code.
	2.	Integrated Development Environment (IDE): Choose an IDE such as IntelliJ IDEA, Eclipse, or NetBeans for writing
	    and managing your Java code. IntelliJ IDEA is widely used in the Selenium community for its robust features.
	3.	Selenium WebDriver: Download Selenium WebDriver libraries and dependencies. WebDriver allows you to automate web
	    browser interactions.
	4.	Cucumber-Java and Cucumber-JUnit: Cucumber is a BDD (Behavior-Driven Development) tool that allows you to write
	    test cases in a human-readable format. You need to add Cucumber dependencies to your project, including cucumber-java
	    and cucumber-junit.
	5.	JUnit: JUnit is a unit testing framework for Java. It’s commonly used with Cucumber for test execution and reporting.
	6.	Browser Drivers: Download browser-specific drivers (e.g., ChromeDriver, GeckoDriver for Firefox, etc.) and configure
	    them in your project. These drivers allow Selenium WebDriver to interact with the respective browsers.
	7.	Maven or Gradle: Maven or Gradle is used as a build automation tool to manage dependencies and build your project.
	    You can choose either Maven or Gradle based on your preference.

Once you have set up these prerequisites, you can start writing automation tests in Java using Selenium with Cucumber.
Make sure to organize your project structure effectively and follow best practices for writing maintainable and efficient
tests.

________________________________________________________________________________________________________________________

2. Framework:
   Combination of multiple tools and designs together that helps us to achieve in development of automation test goals.
   Goal for testing -> Quality Assurance

   A framework in Java, particularly in the context of automation testing with Selenium and Cucumber, provides a structured
   approach for organizing your test code, making it easier to write, maintain, and scale automated tests. Here’s why,
   how, and when you would use a framework:

Why Use a Framework:
	1.	Organization: Frameworks help in organizing your test code into manageable components such as page objects, step
	    definitions, utilities, and test scenarios, improving code readability and maintainability.
	2.	Reusability: With a framework, you can create reusable components and libraries that can be utilized across
	    multiple tests, reducing redundancy and promoting code reuse.
	3.	Modularity: Frameworks encourage modular design, allowing you to separate concerns and components, making it
	    easier to update or modify specific parts of your tests without affecting the entire test suite.
	4.	Reporting: Many frameworks come with built-in reporting capabilities, providing comprehensive test reports with
	    detailed information on test execution, results, and failures, aiding in identifying and troubleshooting issues.

How to Use a Framework:
	1.	Choose a Framework: There are various frameworks available for automation testing in Java, such as TestNG, JUnit,
	    and Cucumber. Choose a framework that best fits your project requirements and preferences.
	2.	Setup: Set up your framework by configuring necessary dependencies, project structure, and environment settings.
	    This includes installing required libraries (e.g., Selenium, Cucumber), setting up browser drivers, and configuring
	    build tools (e.g., Maven, Gradle).
	3.	Design Patterns: Implement design patterns such as Page Object Model (POM), Page Factory, and Singleton to
	    structure your test code effectively and promote reusability and maintainability.
	4.	Write Tests: Write your test scenarios using the chosen framework, following best practices and guidelines.
	    Utilize features provided by the framework, such as annotations, assertions, and parameterization, to create
	    robust and reliable tests.
	5.	Execute Tests: Execute your tests either locally or on a continuous integration (CI) server. Run tests in parallel
	    to speed up execution and improve efficiency.
	6.	Analyze Results: Analyze test results generated by the framework’s reporting mechanism to identify passed, failed,
	    and skipped tests. Use the insights gained to make improvements to your tests and application code.

When to Use a Framework:
	1.	Complexity: When your test suite grows in size and complexity, using a framework becomes essential to manage and
	    maintain your tests effectively.
	2.	Collaboration: If multiple team members are working on the same automation project, using a framework provides a
	    standardized approach, ensuring consistency and collaboration across the team.
	3.	Scalability: When you need to scale your automation efforts to cover a wide range of test scenarios and environments,
	    a framework helps in organizing and scaling your tests efficiently.
	4.	Maintenance: As applications evolve over time, automated tests need to be updated and maintained. A framework
	    simplifies this process by providing a structured and modular approach to test development and maintenance.

In summary,
using a framework in Java for automation testing with Selenium and Cucumber provides numerous benefits in terms of
organization, reusability, modularity, and reporting. By following best practices and leveraging the capabilities of the
chosen framework, you can create robust and maintainable automated tests for your application.

________________________________________________________________________________________________________________________

3. Goal for Testing:
   The goal of testing is to ensure the quality, reliability, and correctness of software products. Testing is an integral
   part of the software development lifecycle, and its primary purposes include:

	1.	Bug Detection: Testing helps identify defects, bugs, or errors in the software before it is deployed to production.
	    Early detection of issues reduces the cost and effort required to fix them later in the development process.
	2.	Verification and Validation: Testing verifies that the software meets the specified requirements and validates that
	    it behaves as expected. It ensures that the software functions correctly and performs the intended tasks according
	    to the defined criteria.
	3.	Quality Assurance: Testing plays a crucial role in ensuring the overall quality of the software by assessing its
	    functionality, performance, security, usability, and other quality attributes. It helps deliver a product that
	    meets or exceeds customer expectations and requirements.
	4.	Risk Mitigation: Testing helps mitigate risks associated with software development by identifying potential issues
	    and vulnerabilities early in the process. Addressing these risks proactively reduces the likelihood of costly
	    failures or incidents in production.
	5.	Customer Satisfaction: Testing contributes to customer satisfaction by delivering a high-quality product that
	    meets user needs, performs reliably, and is free from major defects or issues. It enhances the user experience
	    and builds trust and confidence in the software.
	6.	Compliance and Standards: Testing ensures that the software complies with industry standards, regulations, and
	    best practices. It verifies adherence to legal requirements, security protocols, and quality standards, ensuring
	    that the software meets regulatory and compliance criteria.
	7.	Continuous Improvement: Testing provides valuable feedback for continuous improvement of the software development
	    process. It helps identify areas for optimization, refinement, and enhancement, leading to iterative improvements
	    in software quality and development practices.

Overall,
the primary goal of testing is to deliver high-quality software that meets stakeholder expectations, fulfills business
objectives, and provides value to end-users. Testing helps achieve this goal by detecting defects, verifying functionality,
ensuring quality, mitigating risks, and fostering continuous improvement throughout the software development lifecycle.

________________________________________________________________________________________________________________________

4. Automation Testing:
   In automation testing, particularly when using frameworks like Selenium with Cucumber, converting user stories into
   Java projects involves translating the high-level requirements and acceptance criteria outlined in user stories into
   executable test scripts written in Java. Here’s a more detailed explanation of this process:

	1.	Understanding User Stories: User stories are short, simple descriptions of a feature told from the perspective
	    of the person who desires the new capability, usually a user or customer of the system. They typically follow a
	    template like “As a [user role], I want [feature] so that [benefit]”. Each user story encapsulates a specific
	    functionality or behavior that the software should exhibit.
	2.	Translating User Stories into Acceptance Criteria: User stories are accompanied by acceptance criteria, which
	    define the conditions that must be met for the user story to be considered complete. Acceptance criteria provide
	    detailed descriptions of the expected behavior and outcomes of the feature, serving as guidelines for testing.
	3.	Writing Test Scenarios: Based on the acceptance criteria of each user story, test scenarios are formulated to
	    validate the functionality. Test scenarios outline the steps to be performed, input data to be used, and expected
	    outcomes for verifying that the feature behaves as intended.
	4.	Implementing Test Scripts in Java: Using a framework like Selenium with Cucumber, test scenarios are translated
	    into executable test scripts written in Java. This involves creating step definitions, which are Java methods that
	    define the actions to be taken for each step of the test scenario. These step definitions interact with the
	    application under test using Selenium WebDriver commands to simulate user interactions such as clicking buttons,
	    entering text, and verifying elements.
	5.	Organizing Test Code: Test scripts, along with supporting classes and utilities, are organized within a Java
	    project structure. This typically includes packages for features, step definitions, page objects (if using the
	    Page Object Model pattern), utilities, and configurations. Organizing test code helps maintain readability,
	    modularity, and reusability.
	6.	Executing Tests: Once the test scripts are implemented, they can be executed against the application under test
	    to verify that the functionality meets the acceptance criteria defined in the user stories. Test execution can be
	    performed locally or integrated into a continuous integration (CI) pipeline for automated testing.

By converting user stories into Java projects with executable test scripts, automation testing ensures that the software
behaves as expected and meets the requirements specified by stakeholders. This process facilitates efficient and thorough
validation of software features, leading to higher-quality products and enhanced user satisfaction.

________________________________________________________________________________________________________________________

5. Automation tests can be executed from everywhere:
   it means that the tests can be run from any location or environment where the necessary infrastructure and dependencies
   are available. This flexibility is one of the key advantages of automation testing. Here’s what it entails:

	1.	Local Execution: Automation tests can be executed locally on a developer’s machine or a dedicated testing
	    environment. This allows developers and testers to run tests conveniently during the development process, enabling
	    rapid feedback and debugging of issues.
	2.	Remote Execution: Automation tests can also be executed remotely from a centralized test server or cloud-based
	    testing platform. This enables distributed teams to execute tests from different geographical locations, ensuring
	    consistent test results across various environments.
	3.	Continuous Integration (CI) / Continuous Deployment (CD) Pipelines: Automation tests are often integrated into
	    CI/CD pipelines, where they are executed automatically whenever changes are made to the codebase. This ensures
	    that tests are run consistently and efficiently, facilitating rapid feedback and deployment of changes.
	4.	Integration with Testing Environments: Automation tests can be integrated with different testing environments,
	    such as staging, QA, or production-like environments. This allows for comprehensive testing of the application
	    across various configurations and settings.
	5.	Cross-Browser and Cross-Platform Testing: With automation tools like Selenium WebDriver, tests can be executed
	    across different web browsers (e.g., Chrome, Firefox, Safari) and platforms (e.g., Windows, macOS, Linux). This
	    ensures compatibility and consistency of the application’s behavior across various browser and platform combinations.
	6.	Mobile Testing: Automation tests can also be executed on mobile devices and emulators/simulators, allowing for
	    testing of mobile applications. This enables comprehensive validation of mobile apps across different devices,
	    operating systems, and screen resolutions.

Overall,
the ability to execute automation tests from everywhere provides flexibility, scalability, and efficiency in the testing
process. It enables teams to validate software functionality across diverse environments and configurations, leading to
improved quality, reliability, and user satisfaction.
________________________________________________________________________________________________________________________

6. key components and goals of an automation testing framework. Let’s break it down further:

	1.	Develop Automation Test Scripts: The framework should provide tools and structures to facilitate the creation
	    of automation test scripts. These scripts should adhere to best practices to ensure they are clean, maintainable,
	    reusable, and reliable. Clean code is easy to read and understand, making maintenance and troubleshooting simpler.
	    Maintainable code can be easily updated and modified as needed. Reusable components save time by allowing scripts
	    to leverage existing code rather than reinventing the wheel. Finally, reliable scripts produce consistent results
	    and accurately validate the application’s behavior.
	2.	Have Validations: Automation test scripts should include validations to verify that the application behaves as
	    expected. These validations are assertions or checkpoints that compare the actual outcome of an action with the
	    expected outcome. Validations ensure that the application meets the defined acceptance criteria and functional
	    requirements.
	3.	Execute/Run All the Tests Together (Test Suites): The framework should support the creation and execution of test
	    suites, which are collections of test cases grouped together for efficient execution. Test suites allow multiple
	    tests to be executed sequentially or in parallel, enabling comprehensive testing of the application’s functionality
	    across different scenarios.
	4.	Have Proofs and Reports: The framework should provide mechanisms for generating test reports and evidence of test
	    execution. Test reports document the results of test execution, including passed tests, failed tests, and any
	    errors encountered. These reports serve as proof of the testing effort and provide valuable insights into the
	    application’s quality and stability.
	5.	Can Be Executed Anywhere?: The framework should be designed to be platform-independent and portable, allowing
	    test scripts to be executed in various environments and configurations. This includes local development environments,
	    testing servers, cloud-based platforms, and integrated development pipelines. The ability to execute tests anywhere
	    enhances flexibility, scalability, and accessibility, enabling testing teams to validate the application across
	    diverse setups and scenarios.

In summary,
an automation testing framework combines multiple tools and components to achieve the goals of developing clean,
maintainable, and reliable automation test scripts, performing validations, executing test suites, generating reports,
and enabling test execution anywhere. By fulfilling these objectives, the framework facilitates efficient and effective
automation testing, contributing to the overall quality and reliability of the software product.
________________________________________________________________________________________________________________________

7. Types of Framework:
   popular types of automation testing frameworks:

	1.	BDD (Behavior Driven Development):
	•	BDD is a software development approach that focuses on the behavior of the system from the perspective of its
	    stakeholders.
	•	In BDD, test scenarios are written in a human-readable format using a domain-specific language (DSL) such as
	    Gherkin.
	•	The most common tool used for implementing BDD is Cucumber, which allows the creation of executable specifications
	    in plain text.
	•	BDD encourages collaboration between developers, testers, and business stakeholders to define and automate acceptance
	    criteria.
	•	It promotes communication and understanding among team members by using a common language to describe the behavior
	    of the system.

	2.	TDD (Test Driven Development):
	•	TDD is a software development approach in which test cases are written before the implementation code.
	•	The development cycle in TDD follows the “Red-Green-Refactor” pattern:
	1.	Write a failing test (Red)
	2.	Write the minimum amount of code to pass the test (Green)
	3.	Refactor the code to improve its design and maintainability while keeping the tests passing.
	•	TDD helps drive the design of the software by focusing on writing tests that reflect the desired behavior of the
	    system.
	•	It encourages developers to write modular, loosely coupled, and highly testable code.
	•	TDD often leads to improved code quality, reduced defect rates, and faster development cycles.

These two frameworks,
BDD and TDD, represent different approaches to automated testing, each with its own set of principles, practices, and
benefits. While BDD emphasizes behavior-driven specifications and collaboration among stakeholders, TDD focuses on test-first
development to drive the design and implementation of the software. Both frameworks play crucial roles in promoting test
automation and ensuring the delivery of high-quality software products.

________________________________________________________________________________________________________________________

8. BDD Framework:
   One of the main reasons for the popularity of BDD (Behavior Driven Development) frameworks is the use of a human-readable
   language called Gherkin to define test scenarios and behaviors.
   Here’s why this feature contributes to the widespread adoption of BDD:

	1.	Accessibility: Gherkin syntax is designed to be easily understandable by non-technical stakeholders such as business
	    analysts, product owners, and domain experts. This accessibility fosters collaboration and communication between
	    technical and non-technical team members, ensuring a shared understanding of the desired behavior of the software.
	2.	Clarity and Expressiveness: Gherkin scenarios are written in a structured, plain English format that clearly defines
	    the steps and expected outcomes of each test case. This clarity makes it easier to articulate and document test
	    scenarios, reducing ambiguity and misinterpretation.
	3.	Executable Specifications: Gherkin scenarios serve as executable specifications that can be automated using BDD
	    frameworks like Cucumber. By writing tests in a format that closely resembles natural language, stakeholders can
	    validate the behavior of the system directly from the specifications, bridging the gap between requirements and
	    implementation.
	4.	Reusability and Maintainability: Gherkin scenarios promote the creation of reusable step definitions, which
	    encapsulate the automation logic for each test step. This modular approach improves test maintainability by
	    facilitating updates and modifications to the test scripts without altering the underlying behavior described in
	    the Gherkin scenarios.
	5.	Behavior Focus: Gherkin encourages a behavior-driven approach to testing, where the focus is on defining the expected
	    behavior of the system from the user’s perspective. This shift in mindset promotes a deeper understanding of user
	    needs and business requirements, leading to more effective test coverage and higher-quality software.

Overall,
the use of Gherkin as a plain English language for defining test scenarios and behaviors in BDD frameworks like Cucumber
makes automation testing more accessible, expressive, and aligned with business objectives. This feature contributes
significantly to the popularity and adoption of BDD practices in software development teams.

________________________________________________________________________________________________________________________

9. To create an automation testing framework for BDD (Behavior Driven Development) using the tools mentioned, such as
   Java, Selenium, Cucumber, Gherkin, Maven, Cucumber-report, JUnit, and Object-Oriented Programming (OOP) concepts,
   you can follow these steps:

	1.	Java: Set up Java Development Kit (JDK) on your system to write and compile Java code.
	2.	Selenium: Download and configure Selenium WebDriver libraries for browser automation.
	3.	Cucumber: Add Cucumber dependencies to your project to support BDD-style testing.
	4.	Gherkin: Write test scenarios using Gherkin syntax, which follows the “Given-When-Then” structure.
	5.	Maven: Use Maven as a build automation tool to manage project dependencies and configurations.
	6.	Cucumber-report: Integrate Cucumber-report plugin to generate detailed test reports for analysis.
	7.	JUnit: Incorporate JUnit as a unit testing framework to execute test scenarios and assertions.
	8.	Framework Design (Using OOPs Concepts): Design your framework using object-oriented programming principles for
	    modularity, reusability, and maintainability. Implement concepts such as abstraction, encapsulation, inheritance,
	    and polymorphism to create a robust and scalable framework architecture.

Here’s how you can map the given steps and keywords from BDD scenarios to the corresponding automation framework components:
	•	Given: Define pre-requisite steps and setup actions in your test scenario. Implement corresponding setup methods
	    and configurations in your framework to prepare the test environment.
	•	When: Describe the actions or interactions performed on the application under test. Implement methods to simulate
	    user actions such as clicking buttons, entering text, or navigating through the application.
	•	Then: Specify validation steps to verify the expected behavior or outcomes of the actions. Implement assertion
	    methods to validate the state of the application and ensure that it meets the specified requirements.

By following these steps and utilizing the mentioned tools, you can create a robust automation testing framework for
BDD that supports writing, executing, and reporting on test scenarios using Gherkin syntax with Java, Selenium, and
Cucumber.
________________________________________________________________________________________________________________________

10. Example:
Navigate to Google and Search TekSchool and verify
TekSchool is part of search result.

Given Open browser with Chrome
When Navigate to Google
When Search Tekschool
Then Validate Tekschool is in result.


TDD:
ChromeDriver driver = new ChromeDriver();

…
..
..
Driver.close();

Explanation:
example of a test scenario written in BDD format and how it would be implemented in a TDD-style test script:

BDD Scenario:

Given Open browser with Chrome
When Navigate to Google
When Search Tekschool
Then Validate Tekschool is in result.

Explanation:

	1.	Given: This step sets up the pre-requisite for the test scenario, which is opening the browser with Chrome.
	2.	When: This step describes the action to be performed, which is navigating to the Google homepage.
	3.	And: This additional “When” step performs another action, which is searching for “Tekschool” on Google.
	4.	Then: This step specifies the validation to be performed, which is verifying that “Tekschool” is part of the search
	    results.

TDD Implementation:

// 1. Given - Open browser with Chrome
ChromeDriver driver = new ChromeDriver();

// 2. When - Navigate to Google
driver.get("https://www.google.com");

// 3. When - Search Tekschool
WebElement searchBox = driver.findElement(By.name("q"));
searchBox.sendKeys("Tekschool");
searchBox.sendKeys(Keys.RETURN);

// 4. Then - Validate Tekschool is in result
List<WebElement> searchResults = driver.findElements(By.xpath("//h3"));
boolean isTekschoolFound = false;
for (WebElement result : searchResults) {
    if (result.getText().contains("Tekschool")) {
        isTekschoolFound = true;
        break;
    }
}

// Assertion to validate if Tekschool is found in search results
Assert.assertTrue(isTekschoolFound, "Tekschool is not found in search results.");

// Close the browser after the test completes
driver.quit();

Explanation:

	1.	The test script starts by initializing a new instance of the ChromeDriver, which represents the Chrome browser
	    session.
	2.	It then navigates to the Google homepage using the get() method.
	3.	The script locates the search box on the Google homepage and enters the search query “Tekschool”. It then presses
	    the Enter key to initiate the search.
	4.	After the search results are displayed, the script iterates through the search results to check if “Tekschool”
	    is present in any of the result headings (h3 tags).
	5.	An assertion is used to validate whether “Tekschool” is found in the search results. If it is not found, the test
	    fails with an appropriate message.
	6.	Finally, the browser session is closed using the quit() method.

This TDD-style script follows the Red-Green-Refactor approach by writing the test code before the implementation code.
It verifies the behavior of the application by executing the test steps and validating the expected outcome.

________________________________________________________________________________________________________________________

11. Gerking Language:
    Gherkin is a domain-specific language (DSL) used for defining test scenarios in Behavior Driven Development (BDD).
    It is designed to be human-readable and easily understandable by stakeholders, including business analysts, product
    owners, developers, and testers. Gherkin serves as a common language that facilitates collaboration and communication
    among team members to define and automate acceptance criteria for software features.

When to Use Gherkin:
Gherkin is typically used in BDD methodologies to:
	•	Define acceptance criteria for user stories and features.
	•	Describe behavior-driven test scenarios in a structured format.
	•	Foster collaboration and understanding among team members with diverse backgrounds and roles.
	•	Serve as executable specifications that can be automated using BDD frameworks like Cucumber.

How to Use Gherkin:
Gherkin scenarios follow a structured syntax with keywords such as Given, When, Then, And, and But. Each scenario
describes a specific behavior of the system from the perspective of its users. Here’s a breakdown of the Gherkin syntax
and its usage:
	1.	Feature: Defines the feature under test.
	    Feature: Search Functionality
        As a user
        I want to search for products
        So that I can find the items I'm interested in


	2.	Scenario: Describes a specific test scenario.
	    Scenario: Searching for a product
        Given I am on the homepage
        When I enter "smartphone" in the search bar
        And I click the search button
        Then I should see a list of smartphones


	3.	Scenario Outline: Allows for parameterization of scenarios using example tables.
        Scenario Outline: Searching for different products
        Given I am on the homepage
        When I enter "<product>" in the search bar
        And I click the search button
        Then I should see a list of "<product>"s

        Examples:
        | product    |
        | smartphone |
        | laptop     |
        | headphones |


	4.	Given, When, Then, And, But: Keywords used to define the steps of the scenario.
	•	Given: Sets up the preconditions or initial state of the scenario.
	•	When: Describes the action or event that triggers the behavior being tested.
	•	Then: Specifies the expected outcome or result of the scenario.
	•	And, But: Used to add additional steps or conditions within a scenario.

Example Scenario Using Gherkin:

Feature: Search Functionality
  As a user
  I want to search for products
  So that I can find the items I'm interested in

  Scenario: Searching for a product
    Given I am on the homepage
    When I enter "smartphone" in the search bar
    And I click the search button
    Then I should see a list of smartphones

Explanation:
	•	This Gherkin scenario describes the feature “Search Functionality” from the perspective of a user.
	•	The scenario outlines the steps to search for a product (smartphone) on the homepage and verifies that a list of
	    smartphones is displayed as expected.

In summary,
Gherkin is a powerful tool for describing test scenarios in a structured and human-readable format, facilitating
collaboration and automation in BDD projects. It helps ensure a shared understanding of software requirements and behavior
among team members and stakeholders.
________________________________________________________________________________________________________________________

12. Feature, Scenario, Scenario Outline in Gerking:
    1.	Feature:
	•	A feature represents a high-level description of the functionality or behavior that is being tested. It
	    encapsulates a specific aspect or capability of the software under test.
	•	Features are written at the beginning of a Gherkin file and provide context for the scenarios that follow.
	•	Features are typically defined using the “Feature:” keyword followed by a brief description of the feature.
	•	Example:
Feature: User Authentication
  As a user
  I want to log in to the system
  So that I can access my account


	2.	Scenario:
	•	A scenario represents a specific test case or example that illustrates the behavior of the feature being tested.
	    It describes a sequence of steps and expected outcomes.
	•	Scenarios are written using the “Scenario:” keyword followed by a descriptive title and a series of steps.
	•	Scenarios outline a concrete example of how the feature should behave in a particular situation.
	•	Example:
Scenario: Successful login with valid credentials
  Given I am on the login page
  When I enter valid username and password
  And I click the login button
  Then I should be redirected to the dashboard


	3.	Scenario Outline:
	•	A scenario outline is used to define a template for multiple similar scenarios with varying input data. It allows
	    for parameterization of scenarios using example tables.
	•	Scenario outlines are written using the “Scenario Outline:” keyword followed by a descriptive title and a series
	    of steps.
	•	Instead of providing specific values for inputs, placeholders (e.g., “”) are used in the steps, which are replaced
	    by actual values from example tables during execution.
	•	Scenario outlines are accompanied by an “Examples:” section, which lists different sets of input data for testing.
	•	Example:
Scenario Outline: Adding products to the shopping cart
  Given I am on the product page
  When I add <product> to the cart
  Then the cart should contain <product>

  Examples:
  | product  |
  | iPhone   |
  | Samsung  |
  | Headphones |



Difference Between Scenario and Scenario Outline:
	•	Scenario: Represents a single, concrete test case with fixed inputs and expected outcomes. It provides a specific
	    example of the feature’s behavior.
	•	Scenario Outline: Defines a template for multiple similar test cases with varying input data. It allows for
	    parameterization of scenarios using example tables, enabling the testing of different scenarios using the same
	    template.

________________________________________________________________________________________________________________________

13. Who do we create these tests for:
    They are for The Product Owners, Test Managers, We're creating all these tests to show them and get approval of what the
    behavior or what is the functionality created for this application?
    so we create all these testing, and in the end, we'll get reports and then give it to the managers, POs to understand
    easily so that they won't need any Translations.

    The creation of tests, especially those written in Gherkin syntax for Behavior Driven Development (BDD), serves multiple
    stakeholders involved in the software development process.
    Here’s a breakdown of whom these tests are created for and why:

	1.	Product Owners (POs):
	•	Tests written in Gherkin provide a clear and concise representation of the expected behavior and functionality of
	    the software.
	•	Product Owners use these tests to ensure that the developed features align with the business requirements and user
	    needs.
	•	By reviewing the tests, POs can verify that the development team has understood and implemented the desired
	    features correctly.
	•	Gherkin scenarios serve as executable specifications that enable POs to validate the software’s behavior directly,
	    reducing the need for translations or interpretations.

	2.	Test Managers:
	•	Test Managers use Gherkin tests to plan, organize, and manage the testing efforts within the project.
	•	They can create test plans and strategies based on the defined scenarios to ensure comprehensive coverage of the
	    application’s functionality.
	•	Gherkin tests provide a basis for creating test suites, executing tests, and generating reports to track test
	    progress and outcomes.
	•	Test Managers rely on the reports generated from test executions to assess the quality of the software and identify
	    areas for improvement or further testing.

	3.	Development Team:
	•	The development team utilizes Gherkin tests as executable specifications to guide the implementation of features
	    and functionalities.
	•	Gherkin scenarios serve as acceptance criteria that developers aim to fulfill during the development process.
	•	By following the defined scenarios, developers can ensure that their code aligns with the expected behavior
	    outlined in the tests.

	4.	Collaborative Understanding:
	•	Gherkin tests foster collaboration and communication among stakeholders by providing a common language to describe
	    and verify the software’s behavior.
	•	They serve as a bridge between technical and non-technical team members, facilitating shared understanding and
	    alignment on project goals and requirements.
	•	Gherkin tests eliminate the need for translations or interpretations by providing clear and unambiguous
	    specifications that can be understood by all stakeholders.

Overall,
the creation of Gherkin tests caters to various stakeholders involved in the software development lifecycle, providing
them with a common language to define, verify, and validate the behavior and functionality of the application.
These tests promote collaboration, transparency, and efficiency in the development process, ultimately leading to the
delivery of high-quality software that meets user needs and business objectives.

________________________________________________________________________________________________________________________

14. Gerkin is no for Cucumber, cumcumber is using Gerkin language, this is wrong,
    Gherkin is indeed primarily associated with Cucumber, as it is the language used to define test scenarios in Cucumber.
    Let me clarify:

	1.	Gherkin:
	•	Gherkin is a plain-text, domain-specific language (DSL) used to describe the behavior of software in a structured
	    and human-readable format.
	•	It follows a syntax with keywords such as Feature, Scenario, Given, When, Then, And, and But, which are used to
	    define the steps of test scenarios.
	•	Gherkin scenarios are typically written in .feature files and serve as executable specifications for BDD (Behavior
	    Driven Development) frameworks like Cucumber.

	2.	Cucumber:
	•	Cucumber is a popular BDD tool that enables automated testing of software based on Gherkin scenarios.
	•	It allows developers and testers to write executable specifications in Gherkin syntax and then automate those
	    specifications using step definitions written in programming languages like Java, Ruby, or JavaScript.
	•	Cucumber parses Gherkin scenarios and matches the steps defined in feature files to corresponding step definitions,
	    executing the automation logic accordingly.
	•	Cucumber provides reporting and integration with various testing frameworks and CI/CD tools, making it a powerful
	    tool for behavior-driven testing.

In summary,
Gherkin is indeed the language used to define test scenarios, and Cucumber is the tool that interprets and executes those
scenarios. While Gherkin is not exclusive to Cucumber, it is primarily associated with Cucumber due to its widespread
usage in the context of BDD and automated testing.

________________________________________________________________________________________________________________________

15. Designing the Framework:
    Designing an automation testing framework involves planning and structuring various components to support efficient,
    maintainable, and scalable automated testing. Here are the steps to design an automation testing framework:

	1.	Define Requirements:
	•	Understand the requirements of the project and the testing objectives.
	•	Determine the scope of testing, supported platforms (web, mobile, desktop), and technologies involved.

	2.	Select Tools and Technologies:
	•	Choose appropriate tools and technologies based on the project requirements, team expertise, and compatibility
	    with existing systems.
	•	Consider factors such as programming language (e.g., Java, Python, JavaScript), test automation frameworks
	    (e.g., Selenium, Appium), and supporting tools (e.g., Cucumber, TestNG, JUnit).

	3.	Identify Test Scenarios:
	•	Analyze the application’s functionality and identify test scenarios to be automated.
	•	Prioritize test scenarios based on criticality, frequency of execution, and business impact.

	4.	Define Framework Architecture:
	•	Decide on the architecture and structure of the automation testing framework.
	•	Choose an appropriate design pattern (e.g., Page Object Model, Screenplay Pattern) to organize and manage test
	    code.
	•	Define folder structure, naming conventions, and best practices for coding standards.

	5.	Implement Core Components:
	•	Develop core components of the framework, including:
	•	Test utilities: Reusable functions and libraries for common tasks (e.g., handling browser sessions, interacting
	    with web elements).
	•	Configuration management: Centralized management of test data, environment configurations, and test parameters.
	•	Logging and reporting: Implement logging mechanisms to capture test execution details and generate comprehensive
	    test reports.
	•	Error handling: Implement error handling mechanisms to gracefully handle exceptions and failures during test
	    execution.

	6.	Integrate with Testing Tools:
	•	Integrate the framework with testing tools and libraries to support automation testing.
	•	Set up integrations with test runners (e.g., JUnit, TestNG) for test execution, version control systems (e.g., Git)
	    for code management, and continuous integration (CI) servers (e.g., Jenkins, Travis CI) for automated build and
	    deployment.

	7.	Implement Test Cases:
	•	Write automated test cases using the framework’s structure and components.
	•	Utilize techniques such as data-driven testing, parameterization, and modularization to enhance test reusability
	    and maintainability.

	8.	Implement Reporting and Analysis:
	•	Implement mechanisms to generate comprehensive test reports with detailed test execution results.
	•	Include metrics and insights to analyze test coverage, pass/fail status, execution time, and trends over time.

	9.	Continuous Improvement:
	•	Regularly review and refactor the framework codebase to ensure adherence to best practices and maintainability.
	•	Incorporate feedback from testing activities to enhance the framework’s capabilities and address pain points.

	10.	Documentation and Training:
	•	Document the framework architecture, usage guidelines, and best practices.
	•	Provide training and support to team members to ensure effective adoption and utilization of the framework.

By following these steps, you can design a robust automation testing framework that supports efficient and effective
automated testing of software applications.
________________________________________________________________________________________________________________________

16. Structure of Testing with Cucumber involves three main components:

	1.	Feature File (Gherkin Language):
	•	A feature file is written in Gherkin syntax, which is a human-readable format used to describe the behavior of
	    the software.
	•	Feature files typically have a “.feature” extension and contain one or more scenarios that represent specific test
	    cases or examples.
	•	Each feature file starts with a Feature keyword followed by a brief description of the feature being tested.
	•	Scenarios within the feature file outline the steps of the test case using Given, When, Then, And, and But keywords.
	•	Feature files serve as executable specifications that provide a common language for defining and documenting the
	    expected behavior of the software.
	•	Example Feature File:

Feature: User Authentication
  As a user
  I want to log in to the system
  So that I can access my account

  Scenario: Successful login with valid credentials
    Given I am on the login page
    When I enter valid username and password
    And I click the login button
    Then I should be redirected to the dashboard


	2.	Step Definitions (Java Language):
	•	Step definitions are Java methods that map each step of the scenario outlined in the feature file to executable
	    code.
	•	Each step definition corresponds to a Given, When, Then, And, or But step in the feature file and contains the
	    automation logic to perform the step.
	•	Step definitions are annotated with Cucumber annotations such as @Given, @When, @Then, @And, and @But to specify
	    the type of step they are implementing.
	•	Step definitions interact with the application under test using testing libraries like Selenium WebDriver to
	    simulate user actions and perform validations.
	•	Example Step Definition:

@Given("I am on the login page")
public void navigateToLoginPage() {
    // Code to navigate to the login page
}

@When("I enter valid username and password")
public void enterValidCredentials() {
    // Code to enter valid username and password
}

// Other step definitions for remaining steps of the scenario


	3.	Test Runner (Run Feature Files with JUnit):
	•	The test runner is responsible for executing the feature files and coordinating the execution of step definitions.
	•	In Cucumber, JUnit is commonly used as the test runner to execute feature files.
	•	JUnit annotations such as @RunWith(Cucumber.class) and @CucumberOptions are used to configure the test runner and
	    specify the location of feature files, step definitions, and other configuration options.
	•	The test runner reads the feature files, matches the steps to their corresponding step definitions, and executes
	    the automation logic defined in the step definitions.
	•	Example Test Runner class:

import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = "src/test/resources/features",
    glue = "stepDefinitions"
)
public class TestRunner {
}



In summary,
the structure of testing with Cucumber involves writing feature files in Gherkin syntax to describe test scenarios,
implementing step definitions in Java to automate the steps outlined in the feature files, and using a test runner like
JUnit to execute the feature files and coordinate the execution of step definitions. This structure provides a clear
separation of concerns and enables collaboration between non-technical stakeholders who write feature files and technical
team members who implement step definitions.

________________________________________________________________________________________________________________________

17. Scenario vs Scenario outline:

Scenario:
	•	A Scenario represents a specific test case or example in Gherkin syntax.
	•	It outlines a sequence of steps that describe the behavior of the system under test.
	•	Each Scenario runs once, executing all the defined steps exactly as specified.
	•	Scenarios are used to describe concrete examples of how the system should behave in different situations.
	•	Example:
Scenario: Successful login with valid credentials
  Given I am on the login page
  When I enter valid username and password
  And I click the login button
  Then I should be redirected to the dashboard



Scenario Outline:
	•	A Scenario Outline is used to define a template for multiple similar scenarios with varying input data.
	•	It allows for parameterization of scenarios using example tables, which provide different sets of data for testing.
	•	The Scenario Outline is accompanied by an “Examples” section that lists the input data.
	•	Each line in the Examples section represents a separate instance of the Scenario, with the placeholders replaced
	    by the values from that line.
	•	The entire Scenario is executed once for each line in the Examples section, with the steps using the corresponding
	    data from that line.
	•	Scenario Outlines are useful for testing multiple scenarios with different inputs without duplicating the steps.
	•	Example:
Scenario Outline: Searching for different products
  Given I am on the homepage
  When I search for "<product>"
  Then I should see results for "<product>"

  Examples:
  | product   |
  | smartphone |
  | laptop     |
  | headphones |



In summary,
while regular Scenarios represent single instances of test cases with fixed steps, Scenario Outlines provide a mechanism
for parameterization and testing multiple scenarios with different inputs. The Examples table in a Scenario Outline
serves as the data source for generating multiple instances of the Scenario, with each line representing a separate test
case. This allows for efficient testing of various scenarios with minimal duplication of test steps.

________________________________________________________________________________________________________________________

18. Resource file for Tests, Why do we need this file?
    A resource file for tests, also known as test data or test configuration file, is used to store various types of data
    or configuration settings that are needed for executing automated tests.
    There are several reasons why such a file is necessary:

	1.	Separation of Concerns: Keeping test data separate from test code promotes the principle of separation of concerns.
	    Test data may include input values, expected outcomes, URLs, credentials, environment configurations, or any other
	    parameters required for test execution. By storing this data in a separate file, it is easier to manage, update,
	    and reuse across multiple test cases without modifying the test code itself.
	2.	Maintainability: Test data tends to change frequently due to updates in the application, changes in requirements,
	    or environment configurations. Having a dedicated resource file allows testers to easily update the test data without
	    modifying the test scripts. This improves maintainability and reduces the risk of introducing errors during test
	    maintenance.
	3.	Reusability: Test data files enable the reuse of data across different test cases, scenarios, or even projects.
	    Instead of hardcoding values directly into test scripts, testers can reference data from the resource file, making
	    the tests more modular and adaptable to changes.
	4.	Scalability: As the number of test cases grows, managing test data becomes increasingly complex. By centralizing
	    test data in a resource file, testers can efficiently scale their test suites without cluttering the test code
	    with data-related details.
	5.	Version Control: Resource files can be versioned alongside the test code, allowing changes to be tracked, reviewed,
	    and reverted if necessary. This ensures that test data remains synchronized with the corresponding test scripts
	    and helps maintain consistency across the testing process.
	6.	Collaboration: Resource files facilitate collaboration among team members by providing a centralized repository
	    for test data. Team members can contribute to or modify the test data file as needed without affecting the
	    underlying test scripts, fostering teamwork and productivity.

In summary,
a resource file for tests is essential for managing, organizing, and maintaining test data in a structured and reusable
manner. It promotes separation of concerns, improves maintainability and scalability, facilitates collaboration, and
enhances the overall efficiency of automated testing efforts.

________________________________________________________________________________________________________________________

19. Feature file is not java code, feature file is not written in Java programming language syntax. Instead, it’s written
    in Gherkin syntax, which is a plain-text, domain-specific language (DSL) specifically designed for describing software
    behavior in a human-readable format.

    Gherkin is a language that uses natural language constructs to define test scenarios and features. It provides keywords
    like Feature, Scenario, Given, When, Then, And, and But, which allow testers and stakeholders to express the behavior
    of a system in a structured manner without needing to write code.
    For example, a simple feature file written in Gherkin syntax might look like this:

Feature: Login Functionality
  As a user
  I want to log in to the system
  So that I can access my account

  Scenario: Successful login with valid credentials
    Given I am on the login page
    When I enter valid username and password
    And I click the login button
    Then I should be redirected to the dashboard

In contrast, Java code consists of classes, methods, variables, and other programming constructs written in the Java
programming language. While Java can be used to implement the step definitions that correspond to the steps outlined in
the feature file, the feature file itself is not Java code.

This distinction is important because it emphasizes the separation of concerns between test scenarios (written in Gherkin)
and automation logic (implemented in Java). Gherkin feature files serve as executable specifications that can be understood
by non-technical stakeholders, while Java code is used to automate the execution of those specifications.
________________________________________________________________________________________________________________________

20. Feature File:
    A feature file is a plain-text file used in Behavior Driven Development (BDD) to define and describe the behavior of a
    software feature or functionality. It is written in Gherkin syntax, which is a human-readable format designed to
    express software requirements in a structured manner. Feature files serve as executable specifications that can be
    understood by both technical and non-technical stakeholders.
    Here are some key points about feature files:

	1.	Description of Feature: A feature file typically starts with a brief description of the feature or functionality
	    being tested. This description outlines the purpose of the feature and its intended behavior.
	2.	Scenarios and Scenario Outlines: The main body of a feature file consists of one or more scenarios, each of which
	    describes a specific test case or example of how the feature should behave. Scenarios are written using
	    Given-When-Then steps to outline the preconditions, actions, and expected outcomes of the test case.
	3.	Structured Syntax: Feature files use structured syntax with keywords such as Feature, Scenario, Given, When, Then,
	    And, and But. These keywords help organize the content of the feature file and make it easy to understand.
	4.	Executable Specifications: Feature files serve as executable specifications that define the behavior of the software
	    in a format that can be executed by automation tools like Cucumber. Testers and developers write step definitions
	    to implement the behavior described in the feature files.
	5.	Collaborative Tool: Feature files promote collaboration between technical and non-technical stakeholders by
	    providing a common language for discussing and defining software requirements. They can be reviewed and validated
	    by product owners, business analysts, testers, and developers.
	6.	Readable and Maintainable: Feature files are designed to be human-readable and easy to maintain. They use natural
	    language constructs and are structured in a way that makes it easy to understand the intended behavior of the
	    software.

Overall,
feature files play a crucial role in BDD by providing a structured and collaborative approach to defining software
requirements and behavior. They serve as the foundation for creating automated tests and help ensure that the software
meets the specified requirements and delivers value to end-users.
________________________________________________________________________________________________________________________

21. comments on Cucumber feature files:
    In Cucumber feature files, you can use the hash symbol (#) to add comments. Comments are lines of text that are not
    executed by the Cucumber framework and are solely for the purpose of providing additional context, explanations, or
    annotations within the feature file. Here’s how you can use comments in a Cucumber feature file:

# This is a comment in a Cucumber feature file
# Comments are ignored by the Cucumber framework
# They are used for providing explanations or annotations

Feature: Login Functionality
  As a user
  I want to log in to the system
  So that I can access my account

  # This is a comment for the scenario below
  Scenario: Successful login with valid credentials
    Given I am on the login page
    When I enter valid username and password
    And I click the login button
    Then I should be redirected to the dashboard

  # Another comment for a different scenario
  Scenario: Display error message for invalid login
    Given I am on the login page
    When I enter invalid username and password
    And I click the login button
    Then I should see an error message

In the example above,
lines starting with the hash symbol (#) are treated as comments and are ignored by Cucumber during test execution.
Comments can be added at the beginning of lines or after Gherkin keywords (e.g., Feature, Scenario) to provide context or
explanations for the scenarios and steps. They can also be used to temporarily exclude or comment out specific scenarios
or steps during development or debugging.

________________________________________________________________________________________________________________________

22. Construction of a Feature file:
    A feature file in Cucumber follows a specific structure and contains various components that help define the behavior
    of a software feature or functionality in a human-readable format using Gherkin syntax. Let’s break down the
    construction of a feature file and explain each part:

	1.	Feature:
	•	The Feature keyword is used to define the feature under test.
	•	It is followed by a brief description or title that summarizes the purpose of the feature.
	•	The description should provide context and explain what functionality the feature represents.
	•	Example:
	Feature: Login Functionality
     As a user
     I want to log in to the system
     So that I can access my account


	2.	Scenario:
	•	Scenarios represent specific test cases or examples of how the feature should behave.
	•	Each scenario starts with the Scenario keyword followed by a descriptive title.
	•	Scenarios outline a sequence of steps that describe the actions and expected outcomes of the test case.
	•	Example:
	Scenario: Successful login with valid credentials
     Given I am on the login page
     When I enter valid username and password
     And I click the login button
     Then I should be redirected to the dashboard


	3.	Scenario Outline (Optional):
	•	A Scenario Outline is used to define a template for multiple similar scenarios with varying input data.
	•	It starts with the Scenario Outline keyword followed by a descriptive title.
	•	Scenario Outlines include placeholders (e.g., <placeholder>) in the steps, which are replaced by actual values
	    from an Examples table during execution.
	•	Example:
	Scenario Outline: Searching for different products
     Given I am on the homepage
     When I search for "<product>"
     Then I should see results for "<product>"

      Examples:
      | product   |
      | smartphone |
      | laptop     |
      | headphones |


	4.	Steps:
	•	Steps are the actions or verifications performed in each scenario to interact with the system under test.
	•	Steps are written using Given, When, Then, And, and But keywords to represent preconditions, actions, and expected
	    outcomes.
	•	Each step is written on a new line and starts with one of the keywords followed by a statement.
	•	Example:
    Given I am on the login page
     When I enter valid username and password
     And I click the login button
     Then I should be redirected to the dashboard


	5.	Comments (Optional):
	•	Comments provide additional context, explanations, or annotations within the feature file.
	•	They are lines of text that start with the hash symbol (#) and are ignored by Cucumber during test execution.
	•	Comments can be added to provide clarity, document decisions, or temporarily exclude scenarios or steps.
	•	Example:
    # This is a comment explaining the purpose of the feature file
    # Comments are ignored by Cucumber



In summary,
a feature file in Cucumber consists of a Feature description, one or more Scenarios (and optionally Scenario Outlines),
Steps defining the test actions, and optional Comments for additional context or annotations. Together, these components
form a structured and human-readable representation of the behavior expected from the software feature being tested.
________________________________________________________________________________________________________________________

23. What are Given, When, Then, And/But:
    In Cucumber, the Given-When-Then syntax is used to structure test scenarios in a feature file. Each scenario consists
    of one or more steps, and these steps are categorized using Given, When, Then, And, and But keywords.
    Here’s an explanation of each keyword:

	1.	Given:
	•	The Given keyword is used to set up the preconditions or initial state of the scenario.
	•	It represents the context or background necessary for the scenario to execute.
	•	Given steps establish the starting point of the scenario by defining the conditions that must be true before the
	    action takes place.
	•	Example:
    Given I am on the login page


	2.	When:
	•	The When keyword is used to describe the action or event that is being performed in the scenario.
	•	It represents the user’s interaction with the system under test.
	•	When steps describe the specific action that triggers a change in the system’s state.
	•	Example:
    When I enter valid username and password


	3.	Then:
	•	The Then keyword is used to define the expected outcome or result of the scenario.
	•	It represents the verification or assertion made after the action has been performed.
	•	Then steps assert the expected behavior of the system in response to the action described in the When step.
	•	Example:
    Then I should be redirected to the dashboard


	4.	And / But:
	•	The And and But keywords are used to add additional steps or conditions within a scenario.
	•	They can be used to chain multiple Given, When, or Then steps together for clarity and readability.
	•	And and But keywords can be used interchangeably based on preference and readability.
	•	Example:
    And I click the login button



These keywords help structure test scenarios in a clear and understandable way by dividing them into distinct phases:
Given (preconditions), When (actions), and Then (outcomes). Additional steps within each phase can be added using And or
But to provide more detail or specificity to the scenario. This Given-When-Then syntax serves as a common language for
defining and communicating software requirements and behavior in a human-readable format.

________________________________________________________________________________________________________________________

24. Step Definition:
    A step definition is a piece of code written in a programming language (e.g., Java, Ruby, JavaScript) that defines the
    automation logic to be executed when a step from a feature file is encountered during test execution. Step definitions
    are responsible for mapping the steps described in the feature files to actual actions or verifications performed on
    the application under test.

Here’s a breakdown of what step definitions entail:
	1.	Mapping to Gherkin Steps:
	•	Step definitions define the automation logic corresponding to each Given, When, Then, And, or But step in the
	    feature file.
	•	They typically use regular expressions or annotations to match the steps in the feature file to the corresponding
	    code implementation.

	2.	Automation Logic:
	•	Step definitions contain the actual code to interact with the application under test.
	•	They may use testing libraries (e.g., Selenium WebDriver) to simulate user actions (e.g., clicking buttons,
	    entering text) and perform verifications (e.g., checking page elements, verifying text).

	3.	Data Passing:
	•	Step definitions can receive parameters from the feature file, allowing for dynamic test data and parameterization.
	•	Parameters extracted from feature file steps can be passed as arguments to the step definition methods, enabling
	    flexible and reusable test scenarios.

As for who writes step definitions,
they are typically written by developers or automation engineers who have knowledge of programming languages and testing
frameworks. These individuals are responsible for translating the behavior described in the feature files into executable
automation code.
the implementation details of the step definitions, including the underlying code, automation logic, and technical
intricacies, are known only to the individuals who wrote them. Other stakeholders, such as product owners or manual
testers, may not be familiar with the specific implementation details of the step definitions.

This distinction emphasizes the separation of concerns in the BDD approach:
non-technical stakeholders focus on defining behavior and requirements in feature files, while technical team members
handle the implementation details in the form of step definitions. This separation allows for clearer communication,
collaboration, and maintenance of the testing framework.
________________________________________________________________________________________________________________________

25. Parameters in the step definitions:
    Parameters in step definitions allow for the dynamic passing of data between feature files and the corresponding
    automation code. They enable the reuse of step definitions with varying input values, making test scenarios more
    flexible, maintainable, and reusable. Here’s how parameters work in step definitions:

	1.	Definition:
	•	Parameters are placeholders defined in step definitions that represent dynamic values extracted from the feature
	    file steps.
	•	They are defined using regular expressions or annotations in the step definition method signature.

	2.	Passing Values:
	•	When a step in the feature file contains placeholder values, such as <username> or <password>, these values are
	    extracted and passed as arguments to the corresponding step definition method.
	•	Parameters can represent various types of data, including strings, numbers, dates, or complex objects.

	3.	Flexibility and Reusability:
	•	Parameters make step definitions more flexible and reusable by allowing them to handle different input values without
	    modifying the underlying code.
	•	Test scenarios can be easily parameterized to test different combinations of data or scenarios.

	Example:
	•	Feature File:
    Scenario: Login with valid credentials
     Given I am on the login page
     When I enter username "<username>" and password "<password>"
     And I click the login button
     Then I should be redirected to the dashboard

	•	Step Definition (Java):
    @When("I enter username {string} and password {string}")
     public void enterCredentials(String username, String password) {
     // Automation code to enter username and password
      }



In the example above,
{string} is used as a placeholder in the step definition to represent a string parameter. The values <username> and
<password> from the feature file step are dynamically passed to the enterCredentials method as arguments, allowing the
step definition to interact with the application using the provided username and password values.

Overall,
parameters in step definitions enhance the flexibility, maintainability, and reusability of automated tests by enabling
the dynamic passing of data between feature files and automation code. They play a crucial role in creating scalable and
adaptable test automation frameworks.
________________________________________________________________________________________________________________________

26. Structure of Testing with Cucumber:
    1. Feature file (Gherkin Language)
    2. Step definitions (Java Language)
    3. Test Runner, Run Feature Files (JUnit)

    The structure of testing with Cucumber consists of three main components that work together to facilitate
    behavior-driven testing.
    Here’s an explanation of each component:

	1.	Feature File (Gherkin Language):
	•	The feature file is written in Gherkin syntax, a human-readable format that describes the behavior of the software
	    in a structured manner.
	•	Feature files serve as executable specifications that define the expected behavior of the software feature or
	    functionality.
	•	Each feature file typically represents a specific feature or user story and contains one or more scenarios that
	    outline different test cases or examples.
	•	Scenarios in feature files are written using Given-When-Then steps to describe the preconditions, actions, and
	    expected outcomes of the test cases.
	•	Feature files provide a common language for communication between stakeholders, allowing both technical and
	    non-technical team members to understand and collaborate on the testing process.

	2.	Step Definitions (Java Language):
	•	Step definitions are written in a programming language such as Java and define the automation logic that corresponds
	    to the steps described in the feature files.
	•	Each step in the feature file is mapped to a step definition method, which contains the code to interact with the
	    application under test and perform the necessary actions or verifications.
	•	Step definitions use annotations or regular expressions to match the steps in the feature files and execute the
	    corresponding automation code.
	•	Step definitions interact with testing libraries (e.g., Selenium WebDriver) to simulate user interactions, navigate
	    through the application, and validate the behavior of the software.

	3.	Test Runner (JUnit):
	•	The test runner is responsible for executing the feature files and coordinating the execution of step definitions.
	•	In Cucumber, JUnit is commonly used as the test runner to run feature files and integrate with the underlying
	    automation code.
	•	Test runners execute feature files by scanning them for scenarios and mapping each step to its corresponding step
	    definition.
	•	JUnit annotations are used to configure the test runner and specify the location of feature files, step definitions,
	    and other configuration options.
	•	The test runner orchestrates the execution of the feature files, collects test results, and generates reports to
	    provide insights into the test execution status.

In summary,
the structure of testing with Cucumber involves writing feature files in Gherkin syntax to define the expected behavior of
the software, implementing step definitions in a programming language like Java to automate the steps described in the
feature files, and using a test runner like JUnit to execute the feature files and coordinate the execution of step
definitions.
This structured approach enables behavior-driven testing and fosters collaboration between technical and non-technical
stakeholders throughout the testing process.

In simple terms,
In simple terms, testing with Cucumber involves three main parts:

	1.	Feature File:
	•	This is where you describe what your software should do in a human-readable way. Think of it as writing down a
	    story about how your software should behave. You describe different scenarios or examples of how the software
	    should work, step by step.

	2.	Step Definitions:
	•	These are like the instructions on how to make your story come to life. You write code (usually in Java) to tell
	    the computer what to do for each step in your feature file. For example, if your feature file says
	    “When I enter my username,” your step definition will have the code to actually enter the username into the
	    software.

	3.	Test Runner (JUnit):
	•	This is like the director of your play. It’s a tool that takes your feature file and step definitions and runs
	    them together. It makes sure the right code is executed for each step in your feature file and tells you if
	    everything worked as expected.

So, to sum up,
you write your story in the feature file, write the instructions to make that story happen in the step definitions, and
then use the test runner to bring it all together and see if your software behaves the way you expect.

________________________________________________________________________________________________________________________

27. When using Cucumber, in POM.XML file, it says "<scope>test</scope>, this means that whenever we are writing the tests
    and coding, everything (feature file, step definitions, test runner) should be under the test file and not main because
    compiler will not recognize it as a test
    In a Maven project, the pom.xml file is used to define project configuration, dependencies, and build settings.
    When using Cucumber for testing, the <scope>test</scope> tag in the pom.xml file indicates that certain dependencies
    are only required during the testing phase of the project and should not be included in the main application code.
    Here’s what it means and why it’s important:

	1.	Scope:
	•	In Maven, dependencies can have different scopes that define when they are available during the build process.
	•	The test scope is used for dependencies that are only required during the testing phase of the project.
	•	Dependencies with test scope are not included in the final application package or runtime environment. Instead,
	    they are used specifically for compiling and executing tests.

	2.	Separation of Concerns:
	•	Placing dependencies related to testing (such as Cucumber, JUnit, or other testing libraries) under the test
	    scope ensures a clear separation between production code and test code.
	•	It helps maintain a clean and organized project structure, making it easier to distinguish between code that is
	    part of the main application and code that is used for testing purposes.

	3.	Compiler Recognition:
	•	When dependencies are included with the test scope, they are only available during the test compilation phase.
	•	If test-related dependencies are placed under the main scope, the compiler may not recognize them as part of the
	    testing framework, leading to compilation errors when attempting to execute tests.

	4.	Convention for Test Code:
	•	By convention, feature files, step definitions, test runners, and other test-related artifacts are typically placed
	    under the src/test directory in a Maven project.
	•	This ensures that all test code is located in a designated test source directory, separate from the main application
	    code in the src/main directory.

In summary,
specifying <scope>test</scope> in the pom.xml file for test-related dependencies ensures that they are only available
during the testing phase of the project. This helps maintain separation of concerns, ensures compiler recognition of
test code, and follows conventions for organizing test-related artifacts in the project structure.

________________________________________________________________________________________________________________________

28. Connecting Scenario steps to Step Definition in Java class using Java language:
    To connect steps from a scenario in a feature file to the corresponding step definitions in a Java class, you need to
    follow these steps:

	1.	Write Feature File:
	•	Start by writing your feature file in Gherkin syntax. Define your scenarios with Given-When-Then steps that describe
	    the behavior of your application.

	2.	Implement Step Definitions:
	•	Create a Java class to implement the step definitions corresponding to the steps in your feature file.
	•	In this Java class, create methods annotated with Cucumber annotations (such as @Given, @When, @Then, @And, @But)
	    that match the steps in your feature file.
	•	Inside each method, write the automation code to perform the actions or verifications described by the step.

	3.	Mapping Steps to Step Definitions:
	•	The annotations used in the step definitions (@Given, @When, @Then, etc.) should match the corresponding keywords
	    used in your feature file.
	•	Cucumber uses regular expressions or parameterized annotations to match steps in the feature file with the
	    appropriate step definitions in the Java class.
	•	For example, if your feature file has a step “Given I am on the login page,” your step definition method should be
	    annotated with @Given("I am on the login page").

	4.	Run Tests:
	•	Once your feature file and step definitions are written, you can run your tests using a test runner like JUnit.
	•	The test runner will execute the feature file, match each step to its corresponding step definition method, and
	    execute the automation code defined in the step definitions.
	    Here’s a simplified example to illustrate the process:

1. Feature File (login.feature):
   Feature: Login Functionality

  Scenario: Successful login with valid credentials
    Given I am on the login page
    When I enter valid username and password
    And I click the login button
    Then I should be redirected to the dashboard

2. Step Definitions Java Class:
   import io.cucumber.java.en.*;

public class LoginStepDefinitions {

    @Given("I am on the login page")
    public void navigateToLoginPage() {
        // Automation code to navigate to the login page
    }

    @When("I enter valid username and password")
    public void enterValidCredentials() {
        // Automation code to enter valid username and password
    }

    @And("I click the login button")
    public void clickLoginButton() {
        // Automation code to click the login button
    }

    @Then("I should be redirected to the dashboard")
    public void verifyRedirectToDashboard() {
        // Automation code to verify redirection to the dashboard
    }
}

In this example,
each step in the feature file is mapped to a corresponding method in the LoginStepDefinitions class using Cucumber
annotations. When the feature file is executed, Cucumber will match each step to its corresponding method and execute the
automation code defined in the method.
________________________________________________________________________________________________________________________

29. Annotations:
    An annotation in Java is a special kind of syntactic metadata that provides additional information about classes,
    methods, fields, or other program elements. Annotations do not directly affect the execution of the code but can be
    used by the compiler, runtime environment, or other tools to modify or enhance the behavior of the program.
    Here are some key points about annotations:

	1.	Syntax:
	•	Annotations are denoted by an @ symbol followed by the annotation name, optionally followed by parameters enclosed
	    in parentheses.
	•	Annotations can be placed directly before classes, methods, fields, or other program elements to which they apply.

	2.	Purpose:
	•	Annotations provide metadata about program elements, such as their intended use, behavior, or configuration.
	•	They allow developers to convey information to tools, frameworks, or other components of the development environment.

	3.	Usage:
	•	Annotations can be used for a variety of purposes, including:
	•	Providing hints or instructions to the compiler or runtime environment (e.g., @Override, @Deprecated).
	•	Configuring frameworks and libraries (e.g., Spring, Hibernate).
	•	Enabling runtime reflection and introspection (e.g., JUnit, Mockito).
	•	Generating code, documentation, or other artifacts (e.g., Java EE annotations like @Entity, @WebService).

	4.	Custom Annotations:
	•	In addition to built-in annotations provided by Java and third-party libraries, developers can define their own
	    custom annotations.
	•	Custom annotations can be created by declaring a new annotation type using the @interface keyword.

	5.	Retention Policy:
	•	Annotations can have different retention policies, which determine when they are available and how long they
	    persist.
	•	The three retention policies in Java are SOURCE, CLASS, and RUNTIME, with RUNTIME being the most commonly used
	    for annotations that need to be accessible at runtime.


Overall,
annotations in Java provide a powerful mechanism for adding metadata and enhancing the behavior of Java programs.
They play a crucial role in enabling features such as dependency injection, aspect-oriented programming, testing
frameworks, and more.

In simple terms,
an annotation in Java is like a tag or label that you can attach to classes, methods, or other program elements to give
them extra information or instructions. It’s like adding a sticky note to something in your code to tell Java or other
tools how to treat it.

For example, you might use annotations to:

	•	Tell the compiler to treat a method as overriding a method from a superclass (@Override).
	•	Mark a method as no longer recommended for use (@Deprecated).
	•	Configure a framework to automatically handle certain classes or methods (@Autowired in Spring).
	•	Provide information to testing tools about which methods are test cases (@Test in JUnit).

Annotations are written with an @ symbol followed by the annotation name, and they can also have parameters to provide
additional details. They help make your code more descriptive and can be used by various tools and frameworks to automate
tasks or enforce conventions.
________________________________________________________________________________________________________________________

30. Annotations in Cucumber:
    In Cucumber, annotations are used to connect feature files with the corresponding step definition methods in Java code.
    These annotations help Cucumber understand how to execute the steps described in the feature files by mapping them to
    the appropriate automation logic. Here are some key annotations used in Cucumber:

	1.	Given: This annotation is used to define a step definition method that corresponds to a Given step in the feature
	    file. It represents the initial state or preconditions for the scenario.
	2.	When: This annotation is used to define a step definition method that corresponds to a When step in the feature file.
	    It represents the action or event that triggers a change in the system.
	3.	Then: This annotation is used to define a step definition method that corresponds to a Then step in the feature file.
	    It represents the expected outcome or result of the scenario.
	4.	And / But: These annotations are used to add additional steps within a scenario. They can be used interchangeably
	    with Given, When, or Then annotations to chain multiple steps together.
	5.	Background: This annotation is used to define a step definition method that corresponds to the background section
	    in the feature file. It represents steps that should be executed before each scenario in the feature file.
	6.	Before / After: These annotations are used to define setup and tear down methods that should be executed before
	    and after each scenario or feature. They are often used for setting up test data or cleaning up resources.

These annotations allow Cucumber to automatically match steps in feature files with the appropriate step definition methods
in Java code based on their names and annotations. This mapping enables the execution of automated tests based on the
behavior described in the feature files.

________________________________________________________________________________________________________________________

31. Mapping feature file to java step definitions:
    When we map feature file scenarios to Java step definitions in Cucumber, several things happen:

	1.	Cucumber Library Scanning Java Class:
	•	Cucumber scans the Java classes containing step definitions to identify methods annotated with Cucumber annotations
	    such as @Given, @When, @Then, @And, or @But.
	•	During this scanning process, Cucumber looks for methods whose names match the steps described in the feature files.
	•	It analyzes the annotations and method names to create a mapping between the steps in the feature files and the
	    corresponding step definition methods in the Java class.

	2.	Matching Steps by Text:
	•	Cucumber matches steps in the feature files with step definition methods in the Java class based on their text.
	•	Each step in the feature file is compared with the names of the methods in the Java class to find a match.
	•	If a step in the feature file matches the name of a method in the Java class, Cucumber considers it as a match,
	    regardless of the annotations used on the method.

	3.	Mapping by Annotations:
	•	While matching steps by text is the primary mechanism, annotations on the methods provide additional context and
	    help Cucumber understand the role of each method in the test scenario.
	•	Annotations such as @Given, @When, @Then, @And, and @But specify the type of step (e.g., Given, When, Then)
	    represented by the method.
	•	These annotations guide Cucumber in determining the semantic meaning of each method and how it should be executed
	    within the context of the scenario.

	4.	Execution of Step Definitions:
	•	Once the mapping between feature file steps and step definition methods is established, Cucumber uses this mapping
	    to execute the automation logic defined in the step definition methods.
	•	When a step is encountered during test execution, Cucumber looks up the corresponding step definition method and
	    invokes it, executing the code inside the method.
	•	The automation code inside the step definition method interacts with the application under test, simulating user
	    actions and verifying expected outcomes.

In summary,
when mapping feature file scenarios to Java step definitions in Cucumber, the Cucumber library scans the Java classes
containing step definitions, analyzes annotations and method names, matches steps by text, and uses annotations to guide
the interpretation and execution of step definition methods during test execution. This mapping enables the automation of
test scenarios described in feature files.

in simple terms,
when we map feature file scenarios to Java step definitions in Cucumber:

	1.	Cucumber Looks for Methods:
	•	Cucumber searches through our Java code to find methods that match the steps described in our feature files.

	2.	It Matches Steps by Text:
	•	Cucumber compares each step in the feature file with the names of the methods in our Java code to find a match.
	•	If a step in the feature file has the same name as a method in our Java code, Cucumber considers it a match.

	3.	Annotations Provide Context:
	•	Annotations like @Given, @When, @Then, etc., help Cucumber understand the role of each method in our tests.
	•	They give hints about whether a method represents the starting point, an action, or an expected outcome in our
	    test scenario.

	4.	Execution of Steps:
	•	Once the mapping is established, Cucumber knows which method to execute when it encounters a step during test
	    execution.
	•	It runs the code inside that method, which interacts with our application to perform actions or verify outcomes
	    as described in our feature files.

	    this process allows us to write human-readable feature files describing our test scenarios and then write Java
	    code to make those scenarios come to life and test our application.
________________________________________________________________________________________________________________________

32. For each step definitions that you have in the future file should be at least one and only one implementations.
    we’re referring to the principle of ensuring that every step mentioned in the feature file has a corresponding method
    (implementation) defined in the step definition class. Let’s break it down further:

	1.	At Least One Implementation:
	•	This means that every step described in the feature file should have at least one method in the step definition
	    class that defines its implementation.
	•	Each step in the feature file needs to be mapped to a method in the step definition class to provide the automation
	    logic for that step.
	2.	Only One Implementation:
	•	This implies that there should be a one-to-one mapping between steps in the feature file and methods in the step
	    definition class.
	•	Each step should have exactly one method implementation associated with it, and vice versa.
	•	Having multiple implementations for a single step can lead to confusion and ambiguity in the test framework.

Ensuring that each step has a corresponding method implementation in the step definition class is essential for the proper
execution of automated tests. If a step in the feature file does not have a matching implementation, Cucumber will not be
able to execute that step during test execution, resulting in test failures or errors.

By adhering to this principle, we maintain clarity, consistency, and maintainability in our test automation framework.
It helps ensure that our feature files accurately reflect the intended behavior of the application and that our automation
code effectively tests that behavior.
________________________________________________________________________________________________________________________

33. To run a java project(program), we need to have the main method, but we will not need that for Test runner, it's the
    framework that will run the program and perform the execution.
    In Java, the main method is the entry point for executing a standalone Java application. When you run a Java program,
    the Java Virtual Machine (JVM) looks for the main method and starts executing the code from there.
    However, when it comes to running test automation frameworks like Cucumber, JUnit, or TestNG, we don’t typically
    rely on the main method to kick off the execution. Instead, we use test runners provided by these frameworks to
    execute our tests. Here’s why:

	1.	Test Runner:
	•	Test runners are specialized components provided by testing frameworks that orchestrate the execution of test
	    cases and suites.
	•	They provide the infrastructure needed to discover, execute, and report on tests.
	•	Test runners are responsible for scanning test classes, invoking test methods, managing test lifecycle, and
	    generating test reports.

	2.	Framework Control:
	•	When running tests with frameworks like Cucumber, JUnit, or TestNG, the framework itself takes control of the
	    test execution process.
	•	The framework provides annotations, configuration, and APIs that allow us to define and organize tests, specify
	    test behavior, and manage test execution.
	•	We rely on the framework’s functionality to run our tests, rather than manually invoking a main method.

	3.	Decoupling of Concerns:
	•	Separating the test execution logic from the main application logic promotes modularity and separation of concerns.
	•	Test runners and testing frameworks abstract away the complexities of test execution, allowing developers to
	    focus on writing expressive tests without worrying about the underlying execution mechanism.

	4.	Convention over Configuration:
	•	Testing frameworks often follow the principle of convention over configuration, where they provide default
	    behaviors and sensible defaults for test execution.
	•	By adhering to these conventions, developers can quickly get started with writing and running tests without the
	    need for explicit configuration or custom main methods.

In summary,
while a main method is necessary for standalone Java applications, test automation frameworks like Cucumber rely on test
runners to manage the execution of tests.
Test runners provided by these frameworks handle the orchestration of test execution, allowing developers to focus on
writing expressive and maintainable tests without the need for a main method.
________________________________________________________________________________________________________________________

34. @RunWith(Cucumber.class) and @CucumberOptions() :
    In Java, @RunWith(Cucumber.class) and @CucumberOptions are annotations used in Cucumber to configure and execute
    Cucumber-based tests.
    Here’s what each of these annotations does:

	1.	@RunWith(Cucumber.class):
	•	This annotation is used to specify the test runner class that should be used to execute Cucumber tests.
	•	It tells JUnit (the test framework) to use Cucumber’s test runner (Cucumber.class) to run the Cucumber tests.
	•	By default, JUnit uses its own test runner to execute tests, but when using Cucumber, we need to tell JUnit to
	    use Cucumber’s runner instead.

	2.	@CucumberOptions:
	•	This annotation is used to provide configuration options for Cucumber tests.
	•	It allows us to specify various settings such as the location of feature files, the location of step definitions,
	    tags to include or exclude certain scenarios, output formats for test reports, and more.
	•	@CucumberOptions is typically placed above the class containing the Cucumber tests, and its parameters are used
	    to customize the behavior of the Cucumber test execution.
	•	By using @CucumberOptions, we can customize how Cucumber runs our tests without needing to modify the code of
	    the step definitions or feature files.
     Here’s a basic example of how these annotations might be used together:

import org.junit.runner.RunWith;
import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;

@RunWith(Cucumber.class)
@CucumberOptions(
    features = "src/test/resources/features",
    glue = "com.example.steps",
    tags = "@smoke",
    plugin = {"pretty", "html:target/cucumber-reports"}
)
public class CucumberTestRunner {
    // This class doesn't need any content because the annotations handle the test execution.
}

In this example,
@RunWith(Cucumber.class) tells JUnit to use Cucumber’s test runner, and @CucumberOptions provides various configuration
options such as specifying the location of feature files (features), the location of step definitions (glue), the tags to
include or exclude scenarios (tags), and the output format for test reports (plugin).
________________________________________________________________________________________________________________________

35. In @CucumberOptions annotation, several parameters can be specified to configure the behavior of Cucumber tests.
    Here’s an explanation of the commonly used parameters:

	1.	features:
	•	Specifies the path(s) to the feature files that contain the scenarios to be executed.
	•	You can specify a single feature file or a directory containing multiple feature files.
	•	Example: features = "src/test/resources/features"

	2.	glue:
	•	Specifies the package(s) where Cucumber should look for step definitions.
	•	Cucumber will scan this package and its sub-packages for step definition classes.
	•	Example: glue = "com.example.steps"

	3.	tags:
	•	Specifies the tags that should be included or excluded during test execution.
	•	Scenarios with tags matching the specified criteria will be included or excluded from the test run.
	•	Tags can be used to categorize scenarios and control which scenarios are executed.
	•	Example: tags = "@smoke and not @wip"

	4.	plugin:
	•	Specifies the output formats and destinations for the test execution reports.
	•	You can specify one or more plugins to generate different types of reports, such as HTML, JSON, or JUnit XML.
	•	Example: plugin = {"pretty", "html:target/cucumber-reports"}

	5.	dryRun:
	•	When set to true, Cucumber will only check if all step definitions have corresponding steps in feature files, but
	    won’t execute the actual test steps.
	•	Useful for quickly validating that all steps are implemented without running the entire test suite.
	•	Example: dryRun = true

	6.	strict:
	•	When set to true, Cucumber will fail the execution if any step is undefined or pending (i.e., not implemented).
	•	Useful for enforcing strict adherence to the Given-When-Then structure and ensuring all steps are implemented.
	•	Example: strict = true

	7.	monochrome:
	•	When set to true, Cucumber will output console logs in a readable format without color codes.
	•	Useful for easier readability of console logs, especially in environments that don’t support ANSI color codes.
	•	Example: monochrome = true

These are some of the commonly used parameters in @CucumberOptions annotation, but there are additional parameters
available for more specific configurations. Each parameter provides a way to customize the behavior of Cucumber tests and
adapt them to the needs of your testing environment.

________________________________________________________________________________________________________________________

36. Scenario Outline:
    A Scenario Outline is a feature in Cucumber that allows you to run the same scenario multiple times with different
    sets of data. It’s particularly useful when you have a scenario that you want to test with various inputs or
    combinations of inputs.

Here’s how a Scenario Outline works:

	1.	Scenario Template:
	•	You define a scenario template in your feature file using the Scenario Outline keyword instead of Scenario.
	•	Within the Scenario Outline, you specify placeholders for the data that will vary between each execution of the
	    scenario.

	2.	Examples Table:
	•	Below the Scenario Outline, you provide an Examples table that contains the different sets of data you want to
	    test.
	•	Each row in the Examples table represents a different set of data, with values filling in the placeholders defined
	    in the Scenario Outline.

	3.	Execution:
	•	During execution, Cucumber runs the Scenario Outline once for each row in the Examples table.
	•	For each execution, it substitutes the placeholder values with the corresponding values from the current row of
	    the Examples table.
	•	This effectively allows you to run the same scenario multiple times, each time with different input data.

Here’s a simple example to illustrate a Scenario Outline:

Scenario Outline: Adding numbers
  Given I have entered <number1> into the calculator
  And I have entered <number2> into the calculator
  When I add the numbers
  Then the result should be <sum> on the screen

Examples:
  | number1 | number2 | sum |
  | 5       | 3       | 8   |
  | 10      | 20      | 30  |
  | 8       | 12      | 20  |

In this example,
the Scenario Outline defines a scenario for adding numbers. The placeholders <number1>, <number2>, and <sum> will be
replaced with actual values from the Examples table during execution. The Examples table provides different combinations
of numbers to test the addition operation. Cucumber will execute the scenario three times, once for each row in the
Examples table, substituting the placeholder values accordingly.
________________________________________________________________________________________________________________________

37. Scenario Vs Scenario Outline:
    Regular Scenario runs 1 time for all the steps.
    Scenario outline contains Examples which is data for scenario, the whole scenario will execute per line in Examples.
________________________________________________________________________________________________________________________

38. plugin = "html:target/test_report/report.html"
    In Cucumber, the plugin option in @CucumberOptions annotation allows you to specify the output format and destination
    for the test execution reports.

In the case of plugin = "html:target/test_report/report.html",
it indicates that Cucumber should generate an HTML report for the test execution and save it to the specified location.

Here’s what each part of plugin = "html:target/test_report/report.html" means:

	•	html:: Specifies the output format of the report. In this case, it indicates that the report should be generated
	    in HTML format.
	•	target/test_report/report.html: Specifies the destination path and filename for the generated report.
	    In this example:
	•	target: Represents the output directory where the report will be saved. This is a commonly used directory structure
	    in Maven projects.
	•	test_report: Represents a subdirectory within the target directory where the report will be stored.
	•	report.html: Specifies the filename of the HTML report. The report will be saved as report.html inside the test_report
	    directory.

So,
when you run your Cucumber tests with this plugin configuration, Cucumber will generate an HTML report of the test execution
and save it to the target/test_report/report.html file. This report will typically contain information such as the overall
test results, including the number of scenarios passed, failed, or skipped, along with detailed information about each
scenario, steps, and any errors encountered during execution.
________________________________________________________________________________________________________________________
39.
________________________________________________________________________________________________________________________
40.
________________________________________________________________________________________________________________________
41.
________________________________________________________________________________________________________________________
42.
________________________________________________________________________________________________________________________
43.
________________________________________________________________________________________________________________________
44.
________________________________________________________________________________________________________________________
45.
________________________________________________________________________________________________________________________
46.
________________________________________________________________________________________________________________________
47.
________________________________________________________________________________________________________________________
48.
________________________________________________________________________________________________________________________
49.
________________________________________________________________________________________________________________________
50.
________________________________________________________________________________________________________________________
51.
________________________________________________________________________________________________________________________
52.
________________________________________________________________________________________________________________________
53.
________________________________________________________________________________________________________________________
54.
________________________________________________________________________________________________________________________
55.
________________________________________________________________________________________________________________________
56.
________________________________________________________________________________________________________________________
57.
________________________________________________________________________________________________________________________
58.
________________________________________________________________________________________________________________________
59.
________________________________________________________________________________________________________________________
60.
________________________________________________________________________________________________________________________
61.
________________________________________________________________________________________________________________________
62.
________________________________________________________________________________________________________________________
63.
________________________________________________________________________________________________________________________
64.
________________________________________________________________________________________________________________________
65.
________________________________________________________________________________________________________________________
66.
________________________________________________________________________________________________________________________
67.
________________________________________________________________________________________________________________________
68.
________________________________________________________________________________________________________________________
69.
________________________________________________________________________________________________________________________
70.
________________________________________________________________________________________________________________________
*/
}
